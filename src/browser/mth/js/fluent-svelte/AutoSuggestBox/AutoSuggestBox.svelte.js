/* ./$svelte/fluent-svelte-raw/AutoSuggestBox/AutoSuggestBox.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	append_styles,
	assign,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	outro_and_destroy_block,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out,
	update_keyed_each,
	update_slot_base
} from "mth://.svelte/internal";

import { createEventDispatcher } from "mth://.svelte/internal";
import { uid } from "../internal";
import TextBox from "../TextBox/TextBox.svelte";
import ListItem from "../ListItem/ListItem.svelte";

function add_css(target) {
	append_styles(target, "svelte-11bcpbh", ".auto-suggest-box-flyout.svelte-11bcpbh{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;color:var(--fds-text-primary);inline-size:calc(100% + 2px);inset-block-start:calc(100% + 1px);inset-inline-start:-1px;margin:0;max-block-size:472px;overflow:auto;padding:0;padding-block:2px;position:absolute;z-index:100}.auto-suggest-item-wrapper.svelte-11bcpbh{display:block}.auto-suggest-box.open{background-color:var(--fds-control-fill-input-active)!important}.auto-suggest-box.open .text-box-underline:after{border-bottom:2px solid var(--fds-accent-default);content:\"\"}.auto-suggest-box.open input::-moz-placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open input:-ms-input-placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open input::placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open .text-box-underline{border-bottom-left-radius:0;border-bottom-right-radius:0}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[54] = list[i];
	child_ctx[56] = i;
	return child_ctx;
}

const get_item_template_slot_changes = dirty => ({
	id: dirty[0] & /*matches*/ 8,
	value: dirty[0] & /*value*/ 2,
	matches: dirty[0] & /*matches*/ 8,
	selection: dirty[0] & /*selection*/ 1,
	item: dirty[0] & /*matches*/ 8,
	index: dirty[0] & /*matches*/ 8
});

const get_item_template_slot_context = ctx => ({
	id: "" + (/*flyoutId*/ ctx[14] + "-item-" + /*index*/ ctx[56]),
	value: /*value*/ ctx[1],
	matches: /*matches*/ ctx[3],
	selection: /*selection*/ ctx[0],
	item: /*item*/ ctx[54],
	index: /*index*/ ctx[56]
});

const get_buttons_slot_changes = dirty => ({});
const get_buttons_slot_context = ctx => ({ slot: "buttons" });

// (123:1) {#if open && matches.length > 0}
function create_if_block(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*matches*/ ctx[3];
	const get_key = ctx => /*item*/ ctx[54];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "id", /*flyoutId*/ ctx[14]);
			attr(ul, "role", "listbox");
			attr(ul, "class", "auto-suggest-box-flyout svelte-11bcpbh");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[20](ul);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*flyoutId, matches, selection, value, open*/ 16399 | dirty[1] & /*$$scope*/ 1048576) {
				each_value = /*matches*/ ctx[3];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*ul_binding*/ ctx[20](null);
		}
	};
}

// (136:6) <ListItem        tabindex={-1}        id="{flyoutId}-item-{index}"        role="option"        on:click={() => {         value = matches[selection];         selection = index;         open = false;        }}        selected={selection === index}>
function create_default_slot_1(ctx) {
	let t_value = /*item*/ ctx[54] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*matches*/ 8 && t_value !== (t_value = /*item*/ ctx[54] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (135:6)        
function fallback_block(ctx) {
	let listitem;
	let current;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[19](/*index*/ ctx[56]);
	}

	listitem = new ListItem({
			props: {
				tabindex: -1,
				id: "" + (/*flyoutId*/ ctx[14] + "-item-" + /*index*/ ctx[56]),
				role: "option",
				selected: /*selection*/ ctx[0] === /*index*/ ctx[56],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	listitem.$on("click", click_handler_1);

	return {
		c() {
			create_component(listitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const listitem_changes = {};
			if (dirty[0] & /*matches*/ 8) listitem_changes.id = "" + (/*flyoutId*/ ctx[14] + "-item-" + /*index*/ ctx[56]);
			if (dirty[0] & /*selection, matches*/ 9) listitem_changes.selected = /*selection*/ ctx[0] === /*index*/ ctx[56];

			if (dirty[0] & /*matches*/ 8 | dirty[1] & /*$$scope*/ 1048576) {
				listitem_changes.$$scope = { dirty, ctx };
			}

			listitem.$set(listitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(listitem, detaching);
		}
	};
}

// (125:3) {#each matches as item, index (item)}
function create_each_block(key_1, ctx) {
	let div;
	let t;
	let current;
	const item_template_slot_template = /*#slots*/ ctx[18]["item-template"];
	const item_template_slot = create_slot(item_template_slot_template, ctx, /*$$scope*/ ctx[51], get_item_template_slot_context);
	const item_template_slot_or_fallback = item_template_slot || fallback_block(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			if (item_template_slot_or_fallback) item_template_slot_or_fallback.c();
			t = space();
			attr(div, "class", "auto-suggest-item-wrapper svelte-11bcpbh");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (item_template_slot_or_fallback) {
				item_template_slot_or_fallback.m(div, null);
			}

			append(div, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (item_template_slot) {
				if (item_template_slot.p && (!current || dirty[0] & /*matches, value, selection*/ 11 | dirty[1] & /*$$scope*/ 1048576)) {
					update_slot_base(
						item_template_slot,
						item_template_slot_template,
						ctx,
						/*$$scope*/ ctx[51],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[51])
						: get_slot_changes(item_template_slot_template, /*$$scope*/ ctx[51], dirty, get_item_template_slot_changes),
						get_item_template_slot_context
					);
				}
			} else {
				if (item_template_slot_or_fallback && item_template_slot_or_fallback.p && (!current || dirty[0] & /*matches, selection, value, open*/ 15)) {
					item_template_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(item_template_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(item_template_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (item_template_slot_or_fallback) item_template_slot_or_fallback.d(detaching);
		}
	};
}

// (75:0) <TextBox  type="search"  class="auto-suggest-box {open && matches.length > 0 ? 'open' : ''} {className}"  aria-autocomplete="list"  aria-activedescendant={open && matches.length > 0   ? `${flyoutId}-item-${items.indexOf(matches[selection])}`   : ""}  aria-expanded={open && matches.length > 0}  aria-controls={flyoutId}  on:search={() => {   if (open && matches.length > 0) value = matches[selection];  }}  on:search  on:input  on:input={handleInput}  on:outermousedown={() => (open = false)}  on:focus={() => (focused = true)}  on:focus  on:blur={() => (focused = false)}  on:blur  on:keydown={handleKeyDown}  on:keydown  on:change  on:beforeinput  on:click  on:dblclick  on:contextmenu  on:mousedown  on:mouseup  on:mouseover  on:mouseout  on:mouseenter  on:mouseleave  on:keypress  on:keyup  on:clear={() => {   typedValue = "";   if (items.length > 0) open = true;  }}  on:clear  bind:inputElement  bind:containerElement  bind:clearButtonElement  bind:searchButtonElement  bind:buttonsContainerElement  bind:value  {...$$restProps} >
function create_default_slot(ctx) {
	let t;
	let current;
	let if_block = /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0 && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[51], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*open*/ ctx[2] && /*matches*/ ctx[3].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open, matches*/ 12) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[51],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[51])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[51], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (154:1) 
function create_buttons_slot(ctx) {
	let current;
	const buttons_slot_template = /*#slots*/ ctx[18].buttons;
	const buttons_slot = create_slot(buttons_slot_template, ctx, /*$$scope*/ ctx[51], get_buttons_slot_context);

	return {
		c() {
			if (buttons_slot) buttons_slot.c();
		},
		m(target, anchor) {
			if (buttons_slot) {
				buttons_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (buttons_slot) {
				if (buttons_slot.p && (!current || dirty[1] & /*$$scope*/ 1048576)) {
					update_slot_base(
						buttons_slot,
						buttons_slot_template,
						ctx,
						/*$$scope*/ ctx[51],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[51])
						: get_slot_changes(buttons_slot_template, /*$$scope*/ ctx[51], dirty, get_buttons_slot_changes),
						get_buttons_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(buttons_slot, local);
			current = true;
		},
		o(local) {
			transition_out(buttons_slot, local);
			current = false;
		},
		d(detaching) {
			if (buttons_slot) buttons_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let textbox;
	let updating_inputElement;
	let updating_containerElement;
	let updating_clearButtonElement;
	let updating_searchButtonElement;
	let updating_buttonsContainerElement;
	let updating_value;
	let current;

	const textbox_spread_levels = [
		{ type: "search" },
		{
			class: "auto-suggest-box " + (/*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
			? 'open'
			: '') + " " + /*className*/ ctx[11]
		},
		{ "aria-autocomplete": "list" },
		{
			"aria-activedescendant": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
			? `${/*flyoutId*/ ctx[14]}-item-${/*items*/ ctx[10].indexOf(/*matches*/ ctx[3][/*selection*/ ctx[0]])}`
			: ""
		},
		{
			"aria-expanded": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
		},
		{ "aria-controls": /*flyoutId*/ ctx[14] },
		/*$$restProps*/ ctx[17]
	];

	function textbox_inputElement_binding(value) {
		/*textbox_inputElement_binding*/ ctx[21](value);
	}

	function textbox_containerElement_binding(value) {
		/*textbox_containerElement_binding*/ ctx[22](value);
	}

	function textbox_clearButtonElement_binding(value) {
		/*textbox_clearButtonElement_binding*/ ctx[23](value);
	}

	function textbox_searchButtonElement_binding(value) {
		/*textbox_searchButtonElement_binding*/ ctx[24](value);
	}

	function textbox_buttonsContainerElement_binding(value) {
		/*textbox_buttonsContainerElement_binding*/ ctx[25](value);
	}

	function textbox_value_binding(value) {
		/*textbox_value_binding*/ ctx[26](value);
	}

	let textbox_props = {
		$$slots: {
			buttons: [create_buttons_slot],
			default: [create_default_slot]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < textbox_spread_levels.length; i += 1) {
		textbox_props = assign(textbox_props, textbox_spread_levels[i]);
	}

	if (/*inputElement*/ ctx[4] !== void 0) {
		textbox_props.inputElement = /*inputElement*/ ctx[4];
	}

	if (/*containerElement*/ ctx[5] !== void 0) {
		textbox_props.containerElement = /*containerElement*/ ctx[5];
	}

	if (/*clearButtonElement*/ ctx[7] !== void 0) {
		textbox_props.clearButtonElement = /*clearButtonElement*/ ctx[7];
	}

	if (/*searchButtonElement*/ ctx[8] !== void 0) {
		textbox_props.searchButtonElement = /*searchButtonElement*/ ctx[8];
	}

	if (/*buttonsContainerElement*/ ctx[6] !== void 0) {
		textbox_props.buttonsContainerElement = /*buttonsContainerElement*/ ctx[6];
	}

	if (/*value*/ ctx[1] !== void 0) {
		textbox_props.value = /*value*/ ctx[1];
	}

	textbox = new TextBox({ props: textbox_props });
	binding_callbacks.push(() => bind(textbox, 'inputElement', textbox_inputElement_binding));
	binding_callbacks.push(() => bind(textbox, 'containerElement', textbox_containerElement_binding));
	binding_callbacks.push(() => bind(textbox, 'clearButtonElement', textbox_clearButtonElement_binding));
	binding_callbacks.push(() => bind(textbox, 'searchButtonElement', textbox_searchButtonElement_binding));
	binding_callbacks.push(() => bind(textbox, 'buttonsContainerElement', textbox_buttonsContainerElement_binding));
	binding_callbacks.push(() => bind(textbox, 'value', textbox_value_binding));
	textbox.$on("search", /*search_handler_1*/ ctx[27]);
	textbox.$on("search", /*search_handler*/ ctx[28]);
	textbox.$on("input", /*input_handler*/ ctx[29]);
	textbox.$on("input", /*handleInput*/ ctx[15]);
	textbox.$on("outermousedown", /*outermousedown_handler*/ ctx[30]);
	textbox.$on("focus", /*focus_handler_1*/ ctx[31]);
	textbox.$on("focus", /*focus_handler*/ ctx[32]);
	textbox.$on("blur", /*blur_handler_1*/ ctx[33]);
	textbox.$on("blur", /*blur_handler*/ ctx[34]);
	textbox.$on("keydown", /*handleKeyDown*/ ctx[16]);
	textbox.$on("keydown", /*keydown_handler*/ ctx[35]);
	textbox.$on("change", /*change_handler*/ ctx[36]);
	textbox.$on("beforeinput", /*beforeinput_handler*/ ctx[37]);
	textbox.$on("click", /*click_handler*/ ctx[38]);
	textbox.$on("dblclick", /*dblclick_handler*/ ctx[39]);
	textbox.$on("contextmenu", /*contextmenu_handler*/ ctx[40]);
	textbox.$on("mousedown", /*mousedown_handler*/ ctx[41]);
	textbox.$on("mouseup", /*mouseup_handler*/ ctx[42]);
	textbox.$on("mouseover", /*mouseover_handler*/ ctx[43]);
	textbox.$on("mouseout", /*mouseout_handler*/ ctx[44]);
	textbox.$on("mouseenter", /*mouseenter_handler*/ ctx[45]);
	textbox.$on("mouseleave", /*mouseleave_handler*/ ctx[46]);
	textbox.$on("keypress", /*keypress_handler*/ ctx[47]);
	textbox.$on("keyup", /*keyup_handler*/ ctx[48]);
	textbox.$on("clear", /*clear_handler_1*/ ctx[49]);
	textbox.$on("clear", /*clear_handler*/ ctx[50]);

	return {
		c() {
			create_component(textbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textbox_changes = (dirty[0] & /*open, matches, className, flyoutId, items, selection, $$restProps*/ 150541)
			? get_spread_update(textbox_spread_levels, [
					textbox_spread_levels[0],
					dirty[0] & /*open, matches, className*/ 2060 && {
						class: "auto-suggest-box " + (/*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
						? 'open'
						: '') + " " + /*className*/ ctx[11]
					},
					textbox_spread_levels[2],
					dirty[0] & /*open, matches, flyoutId, items, selection*/ 17421 && {
						"aria-activedescendant": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
						? `${/*flyoutId*/ ctx[14]}-item-${/*items*/ ctx[10].indexOf(/*matches*/ ctx[3][/*selection*/ ctx[0]])}`
						: ""
					},
					dirty[0] & /*open, matches*/ 12 && {
						"aria-expanded": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
					},
					dirty[0] & /*flyoutId*/ 16384 && { "aria-controls": /*flyoutId*/ ctx[14] },
					dirty[0] & /*$$restProps*/ 131072 && get_spread_object(/*$$restProps*/ ctx[17])
				])
			: {};

			if (dirty[0] & /*flyoutElement, matches, selection, value, open*/ 527 | dirty[1] & /*$$scope*/ 1048576) {
				textbox_changes.$$scope = { dirty, ctx };
			}

			if (!updating_inputElement && dirty[0] & /*inputElement*/ 16) {
				updating_inputElement = true;
				textbox_changes.inputElement = /*inputElement*/ ctx[4];
				add_flush_callback(() => updating_inputElement = false);
			}

			if (!updating_containerElement && dirty[0] & /*containerElement*/ 32) {
				updating_containerElement = true;
				textbox_changes.containerElement = /*containerElement*/ ctx[5];
				add_flush_callback(() => updating_containerElement = false);
			}

			if (!updating_clearButtonElement && dirty[0] & /*clearButtonElement*/ 128) {
				updating_clearButtonElement = true;
				textbox_changes.clearButtonElement = /*clearButtonElement*/ ctx[7];
				add_flush_callback(() => updating_clearButtonElement = false);
			}

			if (!updating_searchButtonElement && dirty[0] & /*searchButtonElement*/ 256) {
				updating_searchButtonElement = true;
				textbox_changes.searchButtonElement = /*searchButtonElement*/ ctx[8];
				add_flush_callback(() => updating_searchButtonElement = false);
			}

			if (!updating_buttonsContainerElement && dirty[0] & /*buttonsContainerElement*/ 64) {
				updating_buttonsContainerElement = true;
				textbox_changes.buttonsContainerElement = /*buttonsContainerElement*/ ctx[6];
				add_flush_callback(() => updating_buttonsContainerElement = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 2) {
				updating_value = true;
				textbox_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			textbox.$set(textbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textbox, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"value","items","open","selection","matches","class","inputElement","containerElement","buttonsContainerElement","clearButtonElement","searchButtonElement","flyoutElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value = "" } = $$props;
	let { items = [] } = $$props;
	let { open = false } = $$props;
	let { selection = 0 } = $$props;
	let { matches = [] } = $$props;
	let { class: className = "" } = $$props;
	let { inputElement = null } = $$props;
	let { containerElement = null } = $$props;
	let { buttonsContainerElement = null } = $$props;
	let { clearButtonElement = null } = $$props;
	let { searchButtonElement = null } = $$props;
	let { flyoutElement = null } = $$props;
	let focused = false;
	let typedValue = "";
	const dispatch = createEventDispatcher();
	const flyoutId = uid("fds-auto-suggest-flyout-");

	function dispatchSelect() {
		dispatch("select", { item: items[selection], index: selection });
	}

	function handleInput() {
		$$invalidate(12, typedValue = inputElement.value);
		if (focused && value && items.length > 0) $$invalidate(2, open = true);
	}

	function handleKeyDown(event) {
		const { key } = event;

		if (open && matches.length > 0) {
			if (key === "ArrowDown") {
				$$invalidate(0, selection++, selection);
				if (selection > matches.length - 1) $$invalidate(0, selection = 0);
			} else if (key === "ArrowUp") {
				$$invalidate(0, selection--, selection);
				if (selection < 0) $$invalidate(0, selection = matches.length - 1);
			} else if (key === "Enter" || key === "Escape") {
				$$invalidate(2, open = false);
			}

			if (key === "Enter" || key === "ArrowDown" || key === "ArrowUp") {
				event.preventDefault();
				$$invalidate(1, value = matches[selection]);

				flyoutElement === null || flyoutElement === void 0
				? void 0
				: flyoutElement.children[selection].scrollIntoView({ block: "nearest" });
			}
		} else if (!open && matches.length > 0 && (key === "ArrowDown" || key === "ArrowUp")) {
			$$invalidate(2, open = true);
		}
	}

	const click_handler_1 = index => {
		$$invalidate(1, value = matches[selection]);
		$$invalidate(0, selection = index);
		$$invalidate(2, open = false);
	};

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			flyoutElement = $$value;
			$$invalidate(9, flyoutElement);
		});
	}

	function textbox_inputElement_binding(value) {
		inputElement = value;
		$$invalidate(4, inputElement);
	}

	function textbox_containerElement_binding(value) {
		containerElement = value;
		$$invalidate(5, containerElement);
	}

	function textbox_clearButtonElement_binding(value) {
		clearButtonElement = value;
		$$invalidate(7, clearButtonElement);
	}

	function textbox_searchButtonElement_binding(value) {
		searchButtonElement = value;
		$$invalidate(8, searchButtonElement);
	}

	function textbox_buttonsContainerElement_binding(value) {
		buttonsContainerElement = value;
		$$invalidate(6, buttonsContainerElement);
	}

	function textbox_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	const search_handler_1 = () => {
		if (open && matches.length > 0) $$invalidate(1, value = matches[selection]);
	};

	function search_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	const outermousedown_handler = () => $$invalidate(2, open = false);
	const focus_handler_1 = () => $$invalidate(13, focused = true);

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	const blur_handler_1 = () => $$invalidate(13, focused = false);

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	function contextmenu_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mousedown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseup_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseout_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keyup_handler(event) {
		bubble.call(this, $$self, event);
	}

	const clear_handler_1 = () => {
		$$invalidate(12, typedValue = "");
		if (items.length > 0) $$invalidate(2, open = true);
	};

	function clear_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ('items' in $$new_props) $$invalidate(10, items = $$new_props.items);
		if ('open' in $$new_props) $$invalidate(2, open = $$new_props.open);
		if ('selection' in $$new_props) $$invalidate(0, selection = $$new_props.selection);
		if ('matches' in $$new_props) $$invalidate(3, matches = $$new_props.matches);
		if ('class' in $$new_props) $$invalidate(11, className = $$new_props.class);
		if ('inputElement' in $$new_props) $$invalidate(4, inputElement = $$new_props.inputElement);
		if ('containerElement' in $$new_props) $$invalidate(5, containerElement = $$new_props.containerElement);
		if ('buttonsContainerElement' in $$new_props) $$invalidate(6, buttonsContainerElement = $$new_props.buttonsContainerElement);
		if ('clearButtonElement' in $$new_props) $$invalidate(7, clearButtonElement = $$new_props.clearButtonElement);
		if ('searchButtonElement' in $$new_props) $$invalidate(8, searchButtonElement = $$new_props.searchButtonElement);
		if ('flyoutElement' in $$new_props) $$invalidate(9, flyoutElement = $$new_props.flyoutElement);
		if ('$$scope' in $$new_props) $$invalidate(51, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items, typedValue*/ 5120) {
			$: $$invalidate(3, matches = items.filter(item => item.toLowerCase().includes(typedValue.toLowerCase())));
		}

		if ($$self.$$.dirty[0] & /*selection*/ 1) {
			$: (selection, dispatchSelect());
		}
	};

	return [
		selection,
		value,
		open,
		matches,
		inputElement,
		containerElement,
		buttonsContainerElement,
		clearButtonElement,
		searchButtonElement,
		flyoutElement,
		items,
		className,
		typedValue,
		focused,
		flyoutId,
		handleInput,
		handleKeyDown,
		$$restProps,
		slots,
		click_handler_1,
		ul_binding,
		textbox_inputElement_binding,
		textbox_containerElement_binding,
		textbox_clearButtonElement_binding,
		textbox_searchButtonElement_binding,
		textbox_buttonsContainerElement_binding,
		textbox_value_binding,
		search_handler_1,
		search_handler,
		input_handler,
		outermousedown_handler,
		focus_handler_1,
		focus_handler,
		blur_handler_1,
		blur_handler,
		keydown_handler,
		change_handler,
		beforeinput_handler,
		click_handler,
		dblclick_handler,
		contextmenu_handler,
		mousedown_handler,
		mouseup_handler,
		mouseover_handler,
		mouseout_handler,
		mouseenter_handler,
		mouseleave_handler,
		keypress_handler,
		keyup_handler,
		clear_handler_1,
		clear_handler,
		$$scope
	];
}

class AutoSuggestBox extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 1,
				items: 10,
				open: 2,
				selection: 0,
				matches: 3,
				class: 11,
				inputElement: 4,
				containerElement: 5,
				buttonsContainerElement: 6,
				clearButtonElement: 7,
				searchButtonElement: 8,
				flyoutElement: 9
			},
			add_css,
			[-1, -1]
		);
	}
}

export default AutoSuggestBox;