/* $svelte\fluent-svelte-raw\TextBlock\TextBlock.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	append_styles,
	assign,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	create_slot,
	detach,
	element as element_1,
	empty,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert,
	safe_not_equal,
	set_attributes,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} from "mth://.svelte/internal";

function add_css(target) {
	append_styles(target, "svelte-zxj483", ".text-block.svelte-zxj483{color:currentColor;display:inline-block;margin:0;padding:0}.text-block.type-display.svelte-zxj483,.text-block.type-subtitle.svelte-zxj483,.text-block.type-title.svelte-zxj483,.text-block.type-title-large.svelte-zxj483{font-family:var(--fds-font-family-display);font-weight:600}.text-block.type-body.svelte-zxj483,.text-block.type-body-large.svelte-zxj483,.text-block.type-body-strong.svelte-zxj483{font-family:var(--fds-font-family-text)}.text-block.type-caption.svelte-zxj483{font-family:var(--fds-font-family-small);font-size:var(--fds-caption-font-size);font-weight:400;line-height:16px}.text-block.type-body.svelte-zxj483,.text-block.type-body-large.svelte-zxj483,.text-block.type-body-strong.svelte-zxj483{font-size:var(--fds-body-font-size);font-weight:400;line-height:20px}.text-block.type-body-strong.svelte-zxj483{font-weight:600}.text-block.type-body-large.svelte-zxj483{font-size:var(--fds-body-large-font-size);line-height:24px}.text-block.type-subtitle.svelte-zxj483{font-size:var(--fds-subtitle-font-size);line-height:28px}.text-block.type-title.svelte-zxj483{font-size:var(--fds-title-font-size);line-height:36px}.text-block.type-title-large.svelte-zxj483{font-size:var(--fds-title-large-font-size);line-height:52px}.text-block.type-display.svelte-zxj483{font-size:var(--fds-display-font-size);line-height:92px}");
}

// (38:32) 
function create_if_block_7(ctx) {
	let h1;
	let h1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let h1_levels = [
		{
			class: h1_class_value = "text-block type-display " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let h1_data = {};

	for (let i = 0; i < h1_levels.length; i += 1) {
		h1_data = assign(h1_data, h1_levels[i]);
	}

	return {
		c() {
			h1 = element_1("h1");
			if (default_slot) default_slot.c();
			set_attributes(h1, h1_data);
			toggle_class(h1, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, h1, anchor);

			if (default_slot) {
				default_slot.m(h1, null);
			}

			/*h1_binding*/ ctx[13](h1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(h1, h1_data = get_spread_update(h1_levels, [
				(!current || dirty & /*className*/ 4 && h1_class_value !== (h1_class_value = "text-block type-display " + /*className*/ ctx[2])) && { class: h1_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(h1, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (default_slot) default_slot.d(detaching);
			/*h1_binding*/ ctx[13](null);
		}
	};
}

// (34:35) 
function create_if_block_6(ctx) {
	let h2;
	let h2_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let h2_levels = [
		{
			class: h2_class_value = "text-block type-title-large " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let h2_data = {};

	for (let i = 0; i < h2_levels.length; i += 1) {
		h2_data = assign(h2_data, h2_levels[i]);
	}

	return {
		c() {
			h2 = element_1("h2");
			if (default_slot) default_slot.c();
			set_attributes(h2, h2_data);
			toggle_class(h2, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (default_slot) {
				default_slot.m(h2, null);
			}

			/*h2_binding*/ ctx[12](h2);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(h2, h2_data = get_spread_update(h2_levels, [
				(!current || dirty & /*className*/ 4 && h2_class_value !== (h2_class_value = "text-block type-title-large " + /*className*/ ctx[2])) && { class: h2_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(h2, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (default_slot) default_slot.d(detaching);
			/*h2_binding*/ ctx[12](null);
		}
	};
}

// (30:30) 
function create_if_block_5(ctx) {
	let h3;
	let h3_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let h3_levels = [
		{
			class: h3_class_value = "text-block type-title " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let h3_data = {};

	for (let i = 0; i < h3_levels.length; i += 1) {
		h3_data = assign(h3_data, h3_levels[i]);
	}

	return {
		c() {
			h3 = element_1("h3");
			if (default_slot) default_slot.c();
			set_attributes(h3, h3_data);
			toggle_class(h3, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			/*h3_binding*/ ctx[11](h3);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(h3, h3_data = get_spread_update(h3_levels, [
				(!current || dirty & /*className*/ 4 && h3_class_value !== (h3_class_value = "text-block type-title " + /*className*/ ctx[2])) && { class: h3_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(h3, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (default_slot) default_slot.d(detaching);
			/*h3_binding*/ ctx[11](null);
		}
	};
}

// (26:33) 
function create_if_block_4(ctx) {
	let h4;
	let h4_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let h4_levels = [
		{
			class: h4_class_value = "text-block type-subtitle " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let h4_data = {};

	for (let i = 0; i < h4_levels.length; i += 1) {
		h4_data = assign(h4_data, h4_levels[i]);
	}

	return {
		c() {
			h4 = element_1("h4");
			if (default_slot) default_slot.c();
			set_attributes(h4, h4_data);
			toggle_class(h4, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, h4, anchor);

			if (default_slot) {
				default_slot.m(h4, null);
			}

			/*h4_binding*/ ctx[10](h4);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(h4, h4_data = get_spread_update(h4_levels, [
				(!current || dirty & /*className*/ 4 && h4_class_value !== (h4_class_value = "text-block type-subtitle " + /*className*/ ctx[2])) && { class: h4_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(h4, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h4);
			if (default_slot) default_slot.d(detaching);
			/*h4_binding*/ ctx[10](null);
		}
	};
}

// (22:34) 
function create_if_block_3(ctx) {
	let h5;
	let h5_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let h5_levels = [
		{
			class: h5_class_value = "text-block type-body-large " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let h5_data = {};

	for (let i = 0; i < h5_levels.length; i += 1) {
		h5_data = assign(h5_data, h5_levels[i]);
	}

	return {
		c() {
			h5 = element_1("h5");
			if (default_slot) default_slot.c();
			set_attributes(h5, h5_data);
			toggle_class(h5, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, h5, anchor);

			if (default_slot) {
				default_slot.m(h5, null);
			}

			/*h5_binding*/ ctx[9](h5);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(h5, h5_data = get_spread_update(h5_levels, [
				(!current || dirty & /*className*/ 4 && h5_class_value !== (h5_class_value = "text-block type-body-large " + /*className*/ ctx[2])) && { class: h5_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(h5, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h5);
			if (default_slot) default_slot.d(detaching);
			/*h5_binding*/ ctx[9](null);
		}
	};
}

// (18:35) 
function create_if_block_2(ctx) {
	let h6;
	let h6_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let h6_levels = [
		{
			class: h6_class_value = "text-block type-body-strong " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let h6_data = {};

	for (let i = 0; i < h6_levels.length; i += 1) {
		h6_data = assign(h6_data, h6_levels[i]);
	}

	return {
		c() {
			h6 = element_1("h6");
			if (default_slot) default_slot.c();
			set_attributes(h6, h6_data);
			toggle_class(h6, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, h6, anchor);

			if (default_slot) {
				default_slot.m(h6, null);
			}

			/*h6_binding*/ ctx[8](h6);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(h6, h6_data = get_spread_update(h6_levels, [
				(!current || dirty & /*className*/ 4 && h6_class_value !== (h6_class_value = "text-block type-body-strong " + /*className*/ ctx[2])) && { class: h6_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(h6, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h6);
			if (default_slot) default_slot.d(detaching);
			/*h6_binding*/ ctx[8](null);
		}
	};
}

// (14:29) 
function create_if_block_1(ctx) {
	let span;
	let span_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let span_levels = [
		{
			class: span_class_value = "text-block type-body " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = element_1("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			toggle_class(span, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding_1*/ ctx[7](span);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*className*/ 4 && span_class_value !== (span_class_value = "text-block type-body " + /*className*/ ctx[2])) && { class: span_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(span, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding_1*/ ctx[7](null);
		}
	};
}

// (10:0) {#if variant === "caption"}
function create_if_block(ctx) {
	let span;
	let span_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let span_levels = [
		{
			class: span_class_value = "text-block type-caption " + /*className*/ ctx[2]
		},
		/*$$restProps*/ ctx[3]
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = element_1("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			toggle_class(span, "svelte-zxj483", true);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[6](span);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*className*/ 4 && span_class_value !== (span_class_value = "text-block type-caption " + /*className*/ ctx[2])) && { class: span_class_value },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));

			toggle_class(span, "svelte-zxj483", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[6](null);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variant*/ ctx[1] === "caption") return 0;
		if (/*variant*/ ctx[1] === "body") return 1;
		if (/*variant*/ ctx[1] === "bodyStrong") return 2;
		if (/*variant*/ ctx[1] === "bodyLarge") return 3;
		if (/*variant*/ ctx[1] === "subtitle") return 4;
		if (/*variant*/ ctx[1] === "title") return 5;
		if (/*variant*/ ctx[1] === "titleLarge") return 6;
		if (/*variant*/ ctx[1] === "display") return 7;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["variant","class","element"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { variant = "body" } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;

	function span_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function span_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function h6_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function h5_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function h4_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function h3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function h2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	function h1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('variant' in $$new_props) $$invalidate(1, variant = $$new_props.variant);
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	return [
		element,
		variant,
		className,
		$$restProps,
		$$scope,
		slots,
		span_binding,
		span_binding_1,
		h6_binding,
		h5_binding,
		h4_binding,
		h3_binding,
		h2_binding,
		h1_binding
	];
}

class TextBlock extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { variant: 1, class: 2, element: 0 }, add_css);
	}
}

export default TextBlock;