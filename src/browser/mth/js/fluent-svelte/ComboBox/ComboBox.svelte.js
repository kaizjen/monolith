/* $svelte\fluent-svelte-raw\ComboBox\ComboBox.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	action_destroyer,
	add_flush_callback,
	append,
	append_styles,
	assign,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	create_component,
	create_slot,
	destroy_component,
	destroy_each,
	detach,
	element,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data,
	set_input_value,
	set_style,
	space,
	svg_element,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} from "mth://.svelte/internal";

import { createEventDispatcher, tick } from "mth://.svelte/internal";
import { get_current_component, onMount } from "mth://.svelte/internal";
import { createEventForwarder, externalMouseEvents, uid } from "../internal";
import ComboBoxItem from "./ComboBoxItem.svelte";
import Button from "../Button/Button.svelte";
import TextBox from "../TextBox/TextBoxButton.svelte";
import TextBoxButton from "../TextBox/TextBoxButton.svelte";

function add_css(target) {
	append_styles(target, "svelte-1iqhotm", "@-webkit-keyframes svelte-1iqhotm-menu-in{0%{-webkit-clip-path:var(--fds-grow-clip-path);clip-path:var(--fds-grow-clip-path)}to{-webkit-clip-path:polygon(0 0,100% 0,100% 100%,0 100%);clip-path:polygon(0 0,100% 0,100% 100%,0 100%)}}@keyframes svelte-1iqhotm-menu-in{0%{-webkit-clip-path:var(--fds-grow-clip-path);clip-path:var(--fds-grow-clip-path)}to{-webkit-clip-path:polygon(0 0,100% 0,100% 100%,0 100%);clip-path:polygon(0 0,100% 0,100% 100%,0 100%)}}@-webkit-keyframes svelte-1iqhotm-shadow-in{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}@keyframes svelte-1iqhotm-shadow-in{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}.combo-box.svelte-1iqhotm.svelte-1iqhotm{display:inline-flex;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.combo-box.svelte-1iqhotm .button,.combo-box.svelte-1iqhotm .text-box{flex:1 1 auto}.combo-box.svelte-1iqhotm .text-box{border-color:var(--fds-control-border-default)}.combo-box.svelte-1iqhotm .text-box-underline:after{border-color:transparent}.combo-box.svelte-1iqhotm .text-box-container{cursor:default}.combo-box.svelte-1iqhotm .text-box-container:focus-visible{cursor:text}.combo-box.editable.svelte-1iqhotm .combo-box-textbox:not(:focus-within){border-color:var(--fds-control-border-default);cursor:default}.combo-box.editable.svelte-1iqhotm .combo-box-textbox:not(:focus-within) .text-box-underline:after{content:none}.combo-box.editable.svelte-1iqhotm .combo-box-textbox.disabled{border-color:var(--fds-control-stroke-default)}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox{background-color:var(--fds-control-fill-input-active);cursor:text}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox .text-box-underline:after{border-bottom:2px solid var(--fds-accent-default);content:\"\"}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox input::-moz-placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox input:-ms-input-placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox input::placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-1iqhotm .text-box-underline{border-end-end-radius:0;border-end-start-radius:0}.combo-box.editable.svelte-1iqhotm .combo-box-dropdown.svelte-1iqhotm{border-radius:var(--fds-overlay-corner-radius);border-start-end-radius:0;border-start-start-radius:0;inline-size:100%;inset-block-start:100%;inset-inline-start:0;margin:0}.combo-box.editable.svelte-1iqhotm .combo-box-icon.svelte-1iqhotm{margin:0}.combo-box-label.svelte-1iqhotm.svelte-1iqhotm{flex:1 1 auto;min-block-size:20px;text-align:start}.combo-box-label.placeholder.svelte-1iqhotm.svelte-1iqhotm{color:var(--fds-text-secondary)}.combo-box.disabled.svelte-1iqhotm .placeholder.svelte-1iqhotm{color:var(--fds-text-disabled)}.combo-box-icon.svelte-1iqhotm.svelte-1iqhotm{-webkit-margin-start:8px;block-size:12px;inline-size:12px;margin-inline-start:8px}.combo-box-dropdown.svelte-1iqhotm.svelte-1iqhotm{-webkit-margin-before:-6px;-webkit-margin-start:-5px;-webkit-animation:svelte-1iqhotm-menu-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-1iqhotm-shadow-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration);animation:svelte-1iqhotm-menu-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-1iqhotm-shadow-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration);background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;inline-size:calc(100% + 8px);inset-block-start:var(--fds-menu-offset,0);inset-inline-start:0;margin:0;margin-block-start:-6px;margin-inline-start:-5px;max-block-size:504px;overflow:auto;padding:1px;position:absolute;z-index:100}@supports (overflow:overlay){.combo-box-dropdown.svelte-1iqhotm.svelte-1iqhotm{overflow:overlay}}.combo-box-dropdown.direction-top.svelte-1iqhotm.svelte-1iqhotm{--fds-grow-clip-path:polygon(0 0,100% 0,100% 25%,0 25%)}.combo-box-dropdown.direction-center.svelte-1iqhotm.svelte-1iqhotm{--fds-grow-clip-path:polygon(0 25%,100% 24%,100% 75%,0 75%)}.combo-box-dropdown.direction-bottom.svelte-1iqhotm.svelte-1iqhotm{--fds-grow-clip-path:polygon(0 75%,100% 75%,100% 100%,0 100%)}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[51] = list[i];
	child_ctx[53] = i;
	return child_ctx;
}

// (246:1) {:else}
function create_else_block(ctx) {
	let button;
	let updating_element;
	let current;

	function button_element_binding(value) {
		/*button_element_binding*/ ctx[38](value);
	}

	let button_props = {
		type: "button",
		class: "combo-box-button",
		id: /*buttonId*/ ctx[18],
		"aria-labelledby": /*buttonId*/ ctx[18],
		"aria-haspopup": /*open*/ ctx[1] ? "listbox" : undefined,
		"aria-controls": /*dropdownId*/ ctx[19],
		disabled: /*disabled*/ ctx[11],
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	if (/*buttonElement*/ ctx[7] !== void 0) {
		button_props.element = /*buttonElement*/ ctx[7];
	}

	button = new Button({ props: button_props });
	binding_callbacks.push(() => bind(button, 'element', button_element_binding));
	button.$on("keydown", /*handleKeyboardNavigation*/ ctx[22]);
	button.$on("keydown", /*keydown_handler_1*/ ctx[39]);
	button.$on("click", /*openMenu*/ ctx[21]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*open*/ 2) button_changes["aria-haspopup"] = /*open*/ ctx[1] ? "listbox" : undefined;
			if (dirty[0] & /*disabled*/ 2048) button_changes.disabled = /*disabled*/ ctx[11];

			if (dirty[0] & /*selection, placeholder*/ 8448 | dirty[1] & /*$$scope*/ 65536) {
				button_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*buttonElement*/ 128) {
				updating_element = true;
				button_changes.element = /*buttonElement*/ ctx[7];
				add_flush_callback(() => updating_element = false);
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (199:1) {#if editable}
function create_if_block_2(ctx) {
	let textbox;
	let updating_value;
	let updating_inputElement;
	let current;

	function textbox_value_binding(value) {
		/*textbox_value_binding*/ ctx[32](value);
	}

	function textbox_inputElement_binding(value) {
		/*textbox_inputElement_binding*/ ctx[33](value);
	}

	let textbox_props = {
		clearButton: false,
		class: "combo-box-textbox",
		role: "combobox",
		"aria-activedescendant": /*inputFocused*/ ctx[14],
		"aria-autocomplete": "both",
		"aria-controls": /*dropdownId*/ ctx[19],
		"aria-expanded": /*open*/ ctx[1],
		"aria-haspopup": /*open*/ ctx[1] ? "listbox" : undefined,
		placeholder: /*placeholder*/ ctx[8],
		disabled: /*disabled*/ ctx[11],
		$$slots: { buttons: [create_buttons_slot] },
		$$scope: { ctx }
	};

	if (/*searchValue*/ ctx[3] !== void 0) {
		textbox_props.value = /*searchValue*/ ctx[3];
	}

	if (/*searchInputElement*/ ctx[5] !== void 0) {
		textbox_props.inputElement = /*searchInputElement*/ ctx[5];
	}

	textbox = new TextBox({ props: textbox_props });
	binding_callbacks.push(() => bind(textbox, 'value', textbox_value_binding));
	binding_callbacks.push(() => bind(textbox, 'inputElement', textbox_inputElement_binding));
	textbox.$on("keydown", /*handleKeyboardNavigation*/ ctx[22]);
	textbox.$on("input", /*handleInput*/ ctx[25]);
	textbox.$on("focus", /*handleInputFocus*/ ctx[23]);
	textbox.$on("blur", /*handleInputBlur*/ ctx[24]);
	textbox.$on("change", /*change_handler*/ ctx[34]);
	textbox.$on("input", /*input_handler*/ ctx[35]);
	textbox.$on("beforeinput", /*beforeinput_handler*/ ctx[36]);
	textbox.$on("keydown", /*keydown_handler*/ ctx[37]);

	return {
		c() {
			create_component(textbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textbox_changes = {};
			if (dirty[0] & /*inputFocused*/ 16384) textbox_changes["aria-activedescendant"] = /*inputFocused*/ ctx[14];
			if (dirty[0] & /*open*/ 2) textbox_changes["aria-expanded"] = /*open*/ ctx[1];
			if (dirty[0] & /*open*/ 2) textbox_changes["aria-haspopup"] = /*open*/ ctx[1] ? "listbox" : undefined;
			if (dirty[0] & /*placeholder*/ 256) textbox_changes.placeholder = /*placeholder*/ ctx[8];
			if (dirty[0] & /*disabled*/ 2048) textbox_changes.disabled = /*disabled*/ ctx[11];

			if (dirty[0] & /*open, buttonElement*/ 130 | dirty[1] & /*$$scope*/ 65536) {
				textbox_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*searchValue*/ 8) {
				updating_value = true;
				textbox_changes.value = /*searchValue*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_inputElement && dirty[0] & /*searchInputElement*/ 32) {
				updating_inputElement = true;
				textbox_changes.inputElement = /*searchInputElement*/ ctx[5];
				add_flush_callback(() => updating_inputElement = false);
			}

			textbox.$set(textbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textbox, detaching);
		}
	};
}

// (247:2) <Button    type="button"    class="combo-box-button"    id={buttonId}    aria-labelledby={buttonId}    aria-haspopup={open ? "listbox" : undefined}    aria-controls={dropdownId}    on:keydown={handleKeyboardNavigation}    on:keydown    on:click={openMenu}    bind:element={buttonElement}    {disabled}   >
function create_default_slot_2(ctx) {
	let span;
	let t0_value = (/*selection*/ ctx[13]?.name || /*placeholder*/ ctx[8]) + "";
	let t0;
	let t1;
	let svg;
	let path;

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			attr(span, "class", "combo-box-label svelte-1iqhotm");
			toggle_class(span, "placeholder", !/*selection*/ ctx[13]);
			attr(path, "fill", "currentColor");
			attr(path, "d", "M8.36612 16.1161C7.87796 16.6043 7.87796 17.3957 8.36612 17.8839L23.1161 32.6339C23.6043 33.122 24.3957 33.122 24.8839 32.6339L39.6339 17.8839C40.122 17.3957 40.122 16.6043 39.6339 16.1161C39.1457 15.628 38.3543 15.628 37.8661 16.1161L24 29.9822L10.1339 16.1161C9.64573 15.628 8.85427 15.628 8.36612 16.1161Z");
			attr(svg, "aria-hidden", "true");
			attr(svg, "class", "combo-box-icon svelte-1iqhotm");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "48");
			attr(svg, "height", "48");
			attr(svg, "viewBox", "0 0 48 48");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			insert(target, t1, anchor);
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selection, placeholder*/ 8448 && t0_value !== (t0_value = (/*selection*/ ctx[13]?.name || /*placeholder*/ ctx[8]) + "")) set_data(t0, t0_value);

			if (dirty[0] & /*selection*/ 8192) {
				toggle_class(span, "placeholder", !/*selection*/ ctx[13]);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
			if (detaching) detach(svg);
		}
	};
}

// (222:3) <TextBoxButton     aria-expanded={open}     aria-label="Open dropdown"     aria-controls={dropdownId}     class="combo-box-dropdown-button"     on:click={openMenu}     bind:element={buttonElement}     slot="buttons"    >
function create_default_slot_1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", "currentColor");
			attr(path, "d", "M8.36612 16.1161C7.87796 16.6043 7.87796 17.3957 8.36612 17.8839L23.1161 32.6339C23.6043 33.122 24.3957 33.122 24.8839 32.6339L39.6339 17.8839C40.122 17.3957 40.122 16.6043 39.6339 16.1161C39.1457 15.628 38.3543 15.628 37.8661 16.1161L24 29.9822L10.1339 16.1161C9.64573 15.628 8.85427 15.628 8.36612 16.1161Z");
			attr(svg, "aria-hidden", "true");
			attr(svg, "class", "combo-box-icon svelte-1iqhotm");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "48");
			attr(svg, "height", "48");
			attr(svg, "viewBox", "0 0 48 48");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (222:3) 
function create_buttons_slot(ctx) {
	let textboxbutton;
	let updating_element;
	let current;

	function textboxbutton_element_binding(value) {
		/*textboxbutton_element_binding*/ ctx[31](value);
	}

	let textboxbutton_props = {
		"aria-expanded": /*open*/ ctx[1],
		"aria-label": "Open dropdown",
		"aria-controls": /*dropdownId*/ ctx[19],
		class: "combo-box-dropdown-button",
		slot: "buttons",
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	if (/*buttonElement*/ ctx[7] !== void 0) {
		textboxbutton_props.element = /*buttonElement*/ ctx[7];
	}

	textboxbutton = new TextBoxButton({ props: textboxbutton_props });
	binding_callbacks.push(() => bind(textboxbutton, 'element', textboxbutton_element_binding));
	textboxbutton.$on("click", /*openMenu*/ ctx[21]);

	return {
		c() {
			create_component(textboxbutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textboxbutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textboxbutton_changes = {};
			if (dirty[0] & /*open*/ 2) textboxbutton_changes["aria-expanded"] = /*open*/ ctx[1];

			if (dirty[1] & /*$$scope*/ 65536) {
				textboxbutton_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*buttonElement*/ 128) {
				updating_element = true;
				textboxbutton_changes.element = /*buttonElement*/ ctx[7];
				add_flush_callback(() => updating_element = false);
			}

			textboxbutton.$set(textboxbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textboxbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textboxbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textboxbutton, detaching);
		}
	};
}

// (278:1) {#if !disabled && items.length > 0}
function create_if_block(ctx) {
	let t0;
	let input;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block = /*open*/ ctx[1] && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			input = element("input");
			t1 = space();
			if (default_slot) default_slot.c();
			attr(input, "type", "hidden");
			attr(input, "aria-hidden", "true");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input, anchor);
			/*input_binding*/ ctx[43](input);
			set_input_value(input, /*value*/ ctx[0]);
			insert(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[44]),
					listen(input, "change", /*change_handler_1*/ ctx[28]),
					listen(input, "input", /*input_handler_1*/ ctx[29]),
					listen(input, "beforeinput", /*beforeinput_handler_1*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*open*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[47],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(input);
			/*input_binding*/ ctx[43](null);
			if (detaching) detach(t1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (279:2) {#if open}
function create_if_block_1(ctx) {
	let ul;
	let ul_aria_activedescendant_value;
	let ul_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*items*/ ctx[9];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "id", /*dropdownId*/ ctx[19]);
			attr(ul, "aria-labelledby", /*buttonId*/ ctx[18]);

			attr(ul, "aria-activedescendant", ul_aria_activedescendant_value = /*editable*/ ctx[10]
			? undefined
			: `${/*dropdownId*/ ctx[19]}-item-${/*items*/ ctx[9].indexOf(/*selection*/ ctx[13])}`);

			attr(ul, "role", "listbox");

			attr(ul, "class", ul_class_value = "combo-box-dropdown direction-" + (!/*editable*/ ctx[10]
			? /*menuGrowDirection*/ ctx[16] ?? 'center'
			: 'top') + " svelte-1iqhotm");

			set_style(ul, "--fds-menu-offset", /*menuOffset*/ ctx[15] + "px");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[41](ul);
			current = true;

			if (!mounted) {
				dispose = listen(ul, "blur", /*blur_handler*/ ctx[42]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*items, value, dropdownId, handleKeyboardNavigation, selectItem*/ 5767681) {
				each_value = /*items*/ ctx[9];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*editable, items, selection*/ 9728 && ul_aria_activedescendant_value !== (ul_aria_activedescendant_value = /*editable*/ ctx[10]
			? undefined
			: `${/*dropdownId*/ ctx[19]}-item-${/*items*/ ctx[9].indexOf(/*selection*/ ctx[13])}`)) {
				attr(ul, "aria-activedescendant", ul_aria_activedescendant_value);
			}

			if (!current || dirty[0] & /*editable, menuGrowDirection*/ 66560 && ul_class_value !== (ul_class_value = "combo-box-dropdown direction-" + (!/*editable*/ ctx[10]
			? /*menuGrowDirection*/ ctx[16] ?? 'center'
			: 'top') + " svelte-1iqhotm")) {
				attr(ul, "class", ul_class_value);
			}

			if (!current || dirty[0] & /*menuOffset*/ 32768) {
				set_style(ul, "--fds-menu-offset", /*menuOffset*/ ctx[15] + "px");
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
			/*ul_binding*/ ctx[41](null);
			mounted = false;
			dispose();
		}
	};
}

// (295:5) <ComboBoxItem       role="option"       selected={item.value === value}       disabled={item.disabled}       id="{dropdownId}-item-{i}"       on:keydown={handleKeyboardNavigation}       on:click={() => selectItem(item)}      >
function create_default_slot(ctx) {
	let t0_value = /*item*/ ctx[51].name + "";
	let t0;
	let t1;

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*items*/ 512 && t0_value !== (t0_value = /*item*/ ctx[51].name + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (294:4) {#each items as item, i}
function create_each_block(ctx) {
	let comboboxitem;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[40](/*item*/ ctx[51]);
	}

	comboboxitem = new ComboBoxItem({
			props: {
				role: "option",
				selected: /*item*/ ctx[51].value === /*value*/ ctx[0],
				disabled: /*item*/ ctx[51].disabled,
				id: "" + (/*dropdownId*/ ctx[19] + "-item-" + /*i*/ ctx[53]),
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	comboboxitem.$on("keydown", /*handleKeyboardNavigation*/ ctx[22]);
	comboboxitem.$on("click", click_handler);

	return {
		c() {
			create_component(comboboxitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(comboboxitem, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const comboboxitem_changes = {};
			if (dirty[0] & /*items, value*/ 513) comboboxitem_changes.selected = /*item*/ ctx[51].value === /*value*/ ctx[0];
			if (dirty[0] & /*items*/ 512) comboboxitem_changes.disabled = /*item*/ ctx[51].disabled;

			if (dirty[0] & /*items*/ 512 | dirty[1] & /*$$scope*/ 65536) {
				comboboxitem_changes.$$scope = { dirty, ctx };
			}

			comboboxitem.$set(comboboxitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(comboboxitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(comboboxitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(comboboxitem, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let div_class_value;
	let forwardEvents_action;
	let externalMouseEvents_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_2, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*editable*/ ctx[10]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = !/*disabled*/ ctx[11] && /*items*/ ctx[9].length > 0 && create_if_block(ctx);

	let div_levels = [
		{
			class: div_class_value = "combo-box " + /*className*/ ctx[12]
		},
		/*$$restProps*/ ctx[26]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			set_attributes(div, div_data);
			toggle_class(div, "disabled", /*disabled*/ ctx[11]);
			toggle_class(div, "editable", /*editable*/ ctx[10]);
			toggle_class(div, "open", /*open*/ ctx[1]);
			toggle_class(div, "svelte-1iqhotm", true);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[46](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[17].call(null, div)),
					action_destroyer(externalMouseEvents_action = externalMouseEvents.call(null, div, { type: "mousedown" })),
					listen(div, "outermousedown", /*outermousedown_handler*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t);
			}

			if (!/*disabled*/ ctx[11] && /*items*/ ctx[9].length > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*disabled, items*/ 2560) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*className*/ 4096 && div_class_value !== (div_class_value = "combo-box " + /*className*/ ctx[12])) && { class: div_class_value },
				dirty[0] & /*$$restProps*/ 67108864 && /*$$restProps*/ ctx[26]
			]));

			toggle_class(div, "disabled", /*disabled*/ ctx[11]);
			toggle_class(div, "editable", /*editable*/ ctx[10]);
			toggle_class(div, "open", /*open*/ ctx[1]);
			toggle_class(div, "svelte-1iqhotm", true);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[46](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let itemHeight = 36;

function instance($$self, $$props, $$invalidate) {
	let selectableItems;
	let selection;
	let menuGrowDirection;

	const omit_props_names = [
		"value","searchValue","placeholder","items","editable","disabled","open","class","inputElement","searchInputElement","containerElement","menuElement","buttonElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { value = undefined } = $$props;
	let { searchValue = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { items = [] } = $$props;
	let { editable = false } = $$props;
	let { disabled = false } = $$props;
	let { open = false } = $$props;
	let { class: className = "" } = $$props;
	let { inputElement = null } = $$props;
	let { searchInputElement = null } = $$props;
	let { containerElement = null } = $$props;
	let { menuElement = null } = $$props;
	let { buttonElement = null } = $$props;
	const forwardEvents = createEventForwarder(get_current_component(), ["open", "close", "select", "change", "input", "beforeinput", "keydown"]);
	const dispatch = createEventDispatcher();
	const buttonId = uid("fds-combo-box-button-");
	const dropdownId = uid("fds-combo-box-dropdown-");
	let inputFocused = false;

	let menuOffset = itemHeight * -(selection
	? items.indexOf(selection)
	: Math.floor(items.length / 2));

	onMount(() => {
		if (!searchValue) $$invalidate(3, searchValue = value);
	});

	function updateOffset(target) {
		$$invalidate(15, menuOffset = -(target.offsetTop - parseInt(getComputedStyle(target).getPropertyValue("margin-top"))));
	}

	function selectItem(item) {
		if (item.disabled) return;
		$$invalidate(0, value = item.value);
		$$invalidate(3, searchValue = item.name);
		$$invalidate(1, open = false);
		if (containerElement && !editable) containerElement.children[0].focus();
	}

	async function openMenu() {
		$$invalidate(1, open = !open);
		await tick();
		if (editable && searchInputElement) searchInputElement.focus();
		if (menuElement && selection) updateOffset(menuElement.children[items.indexOf(selection)]);
	}

	async function handleKeyboardNavigation(event) {
		const { key } = event;
		event.stopPropagation();
		const editableClosed = editable && !open;

		// Conditions for closing the menu.
		if (key === "Tab" || key === "Esc" || key === "Escape") $$invalidate(1, open = false);

		// Oh boy, here we go...
		if (key === "ArrowDown" && !editableClosed && !(items.indexOf(selection) >= items.length - 1)) {
			$$invalidate(0, value = selectableItems[selectableItems.indexOf(selection) + 1].value); // If down arrow is pressed, check current selection and move to next non-disabled item.
			$$invalidate(3, searchValue = selectableItems[selectableItems.indexOf(selection) + 1].name);
		} else if (key === "ArrowUp" && !editableClosed && !(items.indexOf(selection) <= 0)) {
			$$invalidate(0, value = selectableItems[selectableItems.indexOf(selection) - 1].value); // Do the same with up arrow.
			$$invalidate(3, searchValue = selectableItems[selectableItems.indexOf(selection) - 1].name);
		} else if (key === "Home") {
			$$invalidate(0, value = selectableItems[0].value); // If home is pressed, move to first non-disabled item.
			$$invalidate(3, searchValue = selectableItems[0].name);
		} else if (key === "End") {
			$$invalidate(0, value = selectableItems[selectableItems.length - 1].value); // If end is pressed, move to last non-disabled item.
			$$invalidate(3, searchValue = selectableItems[selectableItems.length - 1].name);
		} else if (menuElement && selection && key === "Enter") {
			event.preventDefault();
			selectItem(selection); // Select item when the enter key is pressed and the menu is open
		} else if (!menuElement && selection && key === "Enter") {
			openMenu(); // Open the menu when the enter key is pressed and the menu is closed
		} else if (searchInputElement && document.activeElement !== searchInputElement) {
			searchInputElement.focus(); // If the input element has lost focus, regain it.
		}

		// Prevent the browser's default scrolling behavior for these keys
		if (key === "ArrowDown" || key === "ArrowUp" || key === "Home" || key === "End") event.preventDefault();

		// Keybindings for opening the menu when in editable mode using arrow keys
		if (key === "ArrowDown" || key === "ArrowUp" && editable) {
			if (open) {
				await tick();

				searchInputElement === null || searchInputElement === void 0
				? void 0
				: searchInputElement.select(); // Select text when an item is chosen.
			} else {
				$$invalidate(1, open = true);
			}
		}
	}

	function handleInputFocus() {
		searchInputElement.select();
		$$invalidate(14, inputFocused = true);
	}

	function handleInputBlur() {
		$$invalidate(14, inputFocused = false);
	}

	function handleInput(event) {
		const match = selectableItems.find(i => i.name.toLowerCase().startsWith(searchValue.toLowerCase()));
		if (!match) $$invalidate(0, value = null);

		if (match && event.inputType === "insertText" && searchValue.trim() !== "") {
			$$invalidate(5, searchInputElement.value = match.name, searchInputElement);
			searchInputElement.setSelectionRange(searchValue.length, match.name.length);
		}

		if (match && !match.disabled) $$invalidate(0, value = match.value);
		$$invalidate(3, searchValue = searchInputElement.value);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function textboxbutton_element_binding(value) {
		buttonElement = value;
		$$invalidate(7, buttonElement);
	}

	function textbox_value_binding(value) {
		searchValue = value;
		$$invalidate(3, searchValue);
	}

	function textbox_inputElement_binding(value) {
		searchInputElement = value;
		$$invalidate(5, searchInputElement);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function button_element_binding(value) {
		buttonElement = value;
		$$invalidate(7, buttonElement);
	}

	function keydown_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = item => selectItem(item);

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			menuElement = $$value;
			$$invalidate(2, menuElement);
		});
	}

	const blur_handler = () => $$invalidate(1, open = false);

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(4, inputElement);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const outermousedown_handler = () => {
		if (open) $$invalidate(1, open = false);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			containerElement = $$value;
			$$invalidate(6, containerElement);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('searchValue' in $$new_props) $$invalidate(3, searchValue = $$new_props.searchValue);
		if ('placeholder' in $$new_props) $$invalidate(8, placeholder = $$new_props.placeholder);
		if ('items' in $$new_props) $$invalidate(9, items = $$new_props.items);
		if ('editable' in $$new_props) $$invalidate(10, editable = $$new_props.editable);
		if ('disabled' in $$new_props) $$invalidate(11, disabled = $$new_props.disabled);
		if ('open' in $$new_props) $$invalidate(1, open = $$new_props.open);
		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ('inputElement' in $$new_props) $$invalidate(4, inputElement = $$new_props.inputElement);
		if ('searchInputElement' in $$new_props) $$invalidate(5, searchInputElement = $$new_props.searchInputElement);
		if ('containerElement' in $$new_props) $$invalidate(6, containerElement = $$new_props.containerElement);
		if ('menuElement' in $$new_props) $$invalidate(2, menuElement = $$new_props.menuElement);
		if ('buttonElement' in $$new_props) $$invalidate(7, buttonElement = $$new_props.buttonElement);
		if ('$$scope' in $$new_props) $$invalidate(47, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items*/ 512) {
			$: selectableItems = items.filter(item => !item.disabled);
		}

		if ($$self.$$.dirty[0] & /*items, value*/ 513) {
			$: $$invalidate(13, selection = items.find(i => i.value === value));
		}

		if ($$self.$$.dirty[0] & /*menuElement, editable, selection, items*/ 9732) {
			$: if (menuElement && menuElement.children.length > 0 && !editable) {
				if (selection) {
					menuElement.children[items.indexOf(selection)].focus();
				} else {
					menuElement.children[0].focus();
				}
			}
		}

		if ($$self.$$.dirty[0] & /*items, open*/ 514) {
			$: if (items.length > 0) {
				if (open) {
					dispatch("open");
				} else {
					dispatch("close");
				}
			}
		}

		if ($$self.$$.dirty[0] & /*selection*/ 8192) {
			$: dispatch("select", selection);
		}

		if ($$self.$$.dirty[0] & /*selection, items*/ 8704) {
			$: $$invalidate(16, menuGrowDirection = !selection || items[items.indexOf(selection)] === items[Math.floor(items.length / 2)]
			? "center"
			: items.indexOf(selection) < items.indexOf(items[Math.floor(items.length / 2)])
				? "top"
				: "bottom");
		}
	};

	return [
		value,
		open,
		menuElement,
		searchValue,
		inputElement,
		searchInputElement,
		containerElement,
		buttonElement,
		placeholder,
		items,
		editable,
		disabled,
		className,
		selection,
		inputFocused,
		menuOffset,
		menuGrowDirection,
		forwardEvents,
		buttonId,
		dropdownId,
		selectItem,
		openMenu,
		handleKeyboardNavigation,
		handleInputFocus,
		handleInputBlur,
		handleInput,
		$$restProps,
		slots,
		change_handler_1,
		input_handler_1,
		beforeinput_handler_1,
		textboxbutton_element_binding,
		textbox_value_binding,
		textbox_inputElement_binding,
		change_handler,
		input_handler,
		beforeinput_handler,
		keydown_handler,
		button_element_binding,
		keydown_handler_1,
		click_handler,
		ul_binding,
		blur_handler,
		input_binding,
		input_input_handler,
		outermousedown_handler,
		div_binding,
		$$scope
	];
}

class ComboBox extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 0,
				searchValue: 3,
				placeholder: 8,
				items: 9,
				editable: 10,
				disabled: 11,
				open: 1,
				class: 12,
				inputElement: 4,
				searchInputElement: 5,
				containerElement: 6,
				menuElement: 2,
				buttonElement: 7
			},
			add_css,
			[-1, -1]
		);
	}
}

export default ComboBox;