/* $svelte\fluent-svelte-raw\MenuFlyout\MenuFlyoutItem.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	action_destroyer,
	add_flush_callback,
	append,
	append_styles,
	assign,
	attr,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element as element_1,
	empty,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_binding_group_value,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data,
	set_input_value,
	space,
	svg_element,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} from "mth://.svelte/internal";

import { createEventDispatcher, getContext } from "mth://.svelte/internal";
import { get_current_component } from "mth://.svelte/internal";
import { arrowNavigation, uid, createEventForwarder } from "../internal";
import { tabbable } from "../tabbable";
import MenuFlyoutSurface from "../MenuFlyout/MenuFlyoutSurface.svelte";
import TextBlock from "../TextBlock/TextBlock.svelte";

function add_css(target) {
	append_styles(target, "svelte-s7v067", ".menu-flyout-item.svelte-s7v067.svelte-s7v067{align-items:center;background-color:var(--fds-subtle-fill-transparent);block-size:28px;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);cursor:default;display:flex;flex:0 0 auto;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:calc(100% - 8px);line-height:20px;margin:2px 4px;outline:none;padding-inline:12px;position:relative;text-decoration:none;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.menu-flyout-item.svelte-s7v067.svelte-s7v067:before{background-color:var(--fds-accent-default);block-size:0;border-radius:3px;content:\"\";inline-size:3px;inset-inline-start:0;opacity:0;position:absolute;transition:transform var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.menu-flyout-item.svelte-s7v067.svelte-s7v067:focus-visible{box-shadow:var(--fds-focus-stroke)}.menu-flyout-item.selected.svelte-s7v067.svelte-s7v067,.menu-flyout-item.svelte-s7v067.svelte-s7v067:hover,.menu-flyout-item[aria-expanded=true].svelte-s7v067.svelte-s7v067{background-color:var(--fds-subtle-fill-secondary)}.menu-flyout-item.checked.svelte-s7v067 .menu-flyout-item-bullet,.menu-flyout-item.checked.svelte-s7v067 .menu-flyout-item-checkmark{visibility:visible}.menu-flyout-item.svelte-s7v067.svelte-s7v067:active{background-color:var(--fds-subtle-fill-tertiary)}.menu-flyout-item.svelte-s7v067.svelte-s7v067:active:before{transform:scaleY(.625)}.menu-flyout-item.disabled.svelte-s7v067.svelte-s7v067{background-color:var(--fds-subtle-fill-transparent);color:var(--fds-text-disabled);pointer-events:none}.menu-flyout-item.disabled.selected.svelte-s7v067.svelte-s7v067{background-color:var(--fds-subtle-fill-secondary)}.menu-flyout-item.disabled.selected.svelte-s7v067.svelte-s7v067:before{background-color:var(--fds-accent-disabled)}.menu-flyout-item.disabled.svelte-s7v067>.menu-flyout-item-hint{color:var(--fds-text-disabled)}.menu-flyout-item.selected.svelte-s7v067.svelte-s7v067:before{block-size:16px;opacity:1}.menu-flyout-item.indented.svelte-s7v067.svelte-s7v067{-webkit-padding-start:40px;padding-inline-start:40px}.menu-flyout-item-bullet.svelte-s7v067.svelte-s7v067,.menu-flyout-item-checkmark.svelte-s7v067.svelte-s7v067{visibility:hidden}.menu-flyout-item.svelte-s7v067 .menu-flyout-item-arrow.svelte-s7v067{-webkit-margin-end:0;-webkit-margin-start:auto;-webkit-padding-start:24px;block-size:12px;box-sizing:content-box;inline-size:12px;margin-inline-end:0;margin-inline-start:auto;padding-inline-start:24px}.menu-flyout-item-checkmark.svelte-s7v067.svelte-s7v067{-webkit-margin-start:2px;-webkit-margin-end:14px;align-items:center;block-size:12px;display:flex;inline-size:12px;justify-content:center;margin-inline-end:14px;margin-inline-start:2px}.menu-flyout-item-bullet.svelte-s7v067.svelte-s7v067{-webkit-margin-start:6px;-webkit-margin-end:18px;background-color:currentColor;block-size:4px;border-radius:4px;inline-size:4px;margin-inline-end:18px;margin-inline-start:6px}.menu-flyout-item-input-label.svelte-s7v067.svelte-s7v067{display:contents}.menu-flyout-item.svelte-s7v067>svg{fill:currentColor;-webkit-margin-end:12px;block-size:auto;inline-size:16px;margin-inline-end:12px}.menu-flyout-item.svelte-s7v067>.menu-flyout-item-hint{color:var(--fds-text-secondary);flex:1 1 auto;overflow:hidden;padding-left:24px;text-align:end;text-overflow:ellipsis}.menu-flyout-submenu-anchor.svelte-s7v067.svelte-s7v067{--fds-menu-flyout-transition-offset:-50%;inset-block-start:0;inset-inline-start:100%;position:absolute;z-index:10000}");
}

const get_icon_slot_changes_1 = dirty => ({});
const get_icon_slot_context_1 = ctx => ({ slot: "icon" });
const get_flyout_slot_changes = dirty => ({});
const get_flyout_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (151:54) 
function create_if_block_4(ctx) {
	let label;
	let menuflyoutitem;
	let t;
	let current;

	menuflyoutitem = new MenuFlyoutItem({
			props: {
				checked: /*checked*/ ctx[2] || /*group*/ ctx[3] === /*value*/ ctx[4],
				selected: /*selected*/ ctx[12],
				variant: /*variant*/ ctx[9],
				indented: /*indented*/ ctx[13],
				group: /*group*/ ctx[3],
				disabled: /*disabled*/ ctx[14],
				__depth: true,
				$$slots: {
					icon: [create_icon_slot],
					default: [create_default_slot_2]
				},
				$$scope: { ctx }
			}
		});

	function select_block_type_1(ctx, dirty) {
		if (/*variant*/ ctx[9] === "radio") return create_if_block_5;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			label = element_1("label");
			create_component(menuflyoutitem.$$.fragment);
			t = space();
			if_block.c();
			attr(label, "class", "menu-flyout-item-input-label svelte-s7v067");
		},
		m(target, anchor) {
			insert(target, label, anchor);
			mount_component(menuflyoutitem, label, null);
			append(label, t);
			if_block.m(label, null);
			/*label_binding*/ ctx[42](label);
			current = true;
		},
		p(ctx, dirty) {
			const menuflyoutitem_changes = {};
			if (dirty[0] & /*checked, group, value*/ 28) menuflyoutitem_changes.checked = /*checked*/ ctx[2] || /*group*/ ctx[3] === /*value*/ ctx[4];
			if (dirty[0] & /*selected*/ 4096) menuflyoutitem_changes.selected = /*selected*/ ctx[12];
			if (dirty[0] & /*variant*/ 512) menuflyoutitem_changes.variant = /*variant*/ ctx[9];
			if (dirty[0] & /*indented*/ 8192) menuflyoutitem_changes.indented = /*indented*/ ctx[13];
			if (dirty[0] & /*group*/ 8) menuflyoutitem_changes.group = /*group*/ ctx[3];
			if (dirty[0] & /*disabled*/ 16384) menuflyoutitem_changes.disabled = /*disabled*/ ctx[14];

			if (dirty[0] & /*variant*/ 512 | dirty[1] & /*$$scope*/ 4096) {
				menuflyoutitem_changes.$$scope = { dirty, ctx };
			}

			menuflyoutitem.$set(menuflyoutitem_changes);

			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(menuflyoutitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menuflyoutitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			destroy_component(menuflyoutitem);
			if_block.d();
			/*label_binding*/ ctx[42](null);
		}
	};
}

// (96:0) {#if variant === "standard" || __depth}
function create_if_block(ctx) {
	let li;
	let t0;
	let t1;
	let t2;
	let li_tabindex_value;
	let li_aria_expanded_value;
	let li_aria_haspopup_value;
	let li_aria_controls_value;
	let li_aria_selected_value;
	let li_class_value;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const icon_slot_template = /*#slots*/ ctx[26].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[43], get_icon_slot_context);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);
	let if_block0 = /*hint*/ ctx[11] && create_if_block_3(ctx);
	let if_block1 = /*cascading*/ ctx[10] && create_if_block_1(ctx);

	let li_levels = [
		{
			tabindex: li_tabindex_value = /*disabled*/ ctx[14] ? -1 : 0
		},
		{ role: "menuitem" },
		{
			"aria-expanded": li_aria_expanded_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0]
		},
		{
			"aria-haspopup": li_aria_haspopup_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0]
		},
		{
			"aria-controls": li_aria_controls_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*menuId*/ ctx[19]
		},
		{
			"aria-selected": li_aria_selected_value = /*selected*/ ctx[12] || /*checked*/ ctx[2]
		},
		{
			class: li_class_value = "menu-flyout-item type-" + /*variant*/ ctx[9] + " " + /*className*/ ctx[16]
		},
		/*$$restProps*/ ctx[25]
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element_1("li");
			if (icon_slot) icon_slot.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			set_attributes(li, li_data);
			toggle_class(li, "cascading", /*cascading*/ ctx[10]);
			toggle_class(li, "selected", /*selected*/ ctx[12]);
			toggle_class(li, "checked", /*checked*/ ctx[2]);
			toggle_class(li, "disabled", /*disabled*/ ctx[14]);
			toggle_class(li, "indented", /*indented*/ ctx[13]);
			toggle_class(li, "svelte-s7v067", true);
		},
		m(target, anchor) {
			insert(target, li, anchor);

			if (icon_slot) {
				icon_slot.m(li, null);
			}

			append(li, t0);

			if (default_slot) {
				default_slot.m(li, null);
			}

			append(li, t1);
			if (if_block0) if_block0.m(li, null);
			append(li, t2);
			if (if_block1) if_block1.m(li, null);
			/*li_binding*/ ctx[36](li);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[18].call(null, li)),
					listen(li, "click", /*close*/ ctx[20]),
					listen(li, "mouseenter", /*handleMouseEnter*/ ctx[22]),
					listen(li, "mouseleave", /*handleMouseLeave*/ ctx[23]),
					listen(li, "keydown", /*handleKeyDown*/ ctx[21])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[43], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
						null
					);
				}
			}

			if (/*hint*/ ctx[11]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hint*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(li, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*cascading*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*cascading*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[0] & /*disabled*/ 16384 && li_tabindex_value !== (li_tabindex_value = /*disabled*/ ctx[14] ? -1 : 0)) && { tabindex: li_tabindex_value },
				{ role: "menuitem" },
				(!current || dirty[0] & /*$$slots, disabled, open*/ 16793601 && li_aria_expanded_value !== (li_aria_expanded_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0])) && { "aria-expanded": li_aria_expanded_value },
				(!current || dirty[0] & /*$$slots, disabled, open*/ 16793601 && li_aria_haspopup_value !== (li_aria_haspopup_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0])) && { "aria-haspopup": li_aria_haspopup_value },
				(!current || dirty[0] & /*$$slots, disabled*/ 16793600 && li_aria_controls_value !== (li_aria_controls_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*menuId*/ ctx[19])) && { "aria-controls": li_aria_controls_value },
				(!current || dirty[0] & /*selected, checked*/ 4100 && li_aria_selected_value !== (li_aria_selected_value = /*selected*/ ctx[12] || /*checked*/ ctx[2])) && { "aria-selected": li_aria_selected_value },
				(!current || dirty[0] & /*variant, className*/ 66048 && li_class_value !== (li_class_value = "menu-flyout-item type-" + /*variant*/ ctx[9] + " " + /*className*/ ctx[16])) && { class: li_class_value },
				dirty[0] & /*$$restProps*/ 33554432 && /*$$restProps*/ ctx[25]
			]));

			toggle_class(li, "cascading", /*cascading*/ ctx[10]);
			toggle_class(li, "selected", /*selected*/ ctx[12]);
			toggle_class(li, "checked", /*checked*/ ctx[2]);
			toggle_class(li, "disabled", /*disabled*/ ctx[14]);
			toggle_class(li, "indented", /*indented*/ ctx[13]);
			toggle_class(li, "svelte-s7v067", true);
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot, local);
			transition_in(default_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(icon_slot, local);
			transition_out(default_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (icon_slot) icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*li_binding*/ ctx[36](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (165:4) {#if variant === "toggle"}
function create_if_block_6(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M9.85355 3.14645C10.0488 3.34171 10.0488 3.65829 9.85355 3.85355L5.35355 8.35355C5.15829 8.54882 4.84171 8.54882 4.64645 8.35355L2.64645 6.35355C2.45118 6.15829 2.45118 5.84171 2.64645 5.64645C2.84171 5.45118 3.15829 5.45118 3.35355 5.64645L5 7.29289L9.14645 3.14645C9.34171 2.95118 9.65829 2.95118 9.85355 3.14645Z");
			attr(path, "fill", "currentColor");
			attr(svg, "width", "12");
			attr(svg, "height", "12");
			attr(svg, "viewBox", "0 0 12 12");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (154:2) <svelte:self    checked={checked || group === value}    {selected}    {variant}    {indented}    {group}    {disabled}    __depth   >
function create_default_slot_2(ctx) {
	let div;
	let div_class_value;
	let t;
	let current;
	let if_block = /*variant*/ ctx[9] === "toggle" && create_if_block_6(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

	return {
		c() {
			div = element_1("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "menu-flyout-item-" + (/*variant*/ ctx[9] === 'radio' ? 'bullet' : 'checkmark') + " svelte-s7v067");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			insert(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*variant*/ ctx[9] === "toggle") {
				if (if_block) {
					
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty[0] & /*variant*/ 512 && div_class_value !== (div_class_value = "menu-flyout-item-" + (/*variant*/ ctx[9] === 'radio' ? 'bullet' : 'checkmark') + " svelte-s7v067")) {
				attr(div, "class", div_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (detaching) detach(t);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (163:3) 
function create_icon_slot(ctx) {
	let current;
	const icon_slot_template = /*#slots*/ ctx[26].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[43], get_icon_slot_context_1);

	return {
		c() {
			if (icon_slot) icon_slot.c();
		},
		m(target, anchor) {
			if (icon_slot) {
				icon_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[43], dirty, get_icon_slot_changes_1),
						get_icon_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot, local);
			current = true;
		},
		o(local) {
			transition_out(icon_slot, local);
			current = false;
		},
		d(detaching) {
			if (icon_slot) icon_slot.d(detaching);
		}
	};
}

// (196:2) {:else}
function create_else_block(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element_1("input");
			attr(input, "type", "checkbox");
			input.hidden = true;
			input.disabled = /*disabled*/ ctx[14];
			/*$$binding_groups*/ ctx[38][0].push(input);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_1*/ ctx[40](input);
			input.checked = ~/*group*/ ctx[3].indexOf(input.__value);
			input.checked = /*checked*/ ctx[2];
			set_input_value(input, /*value*/ ctx[4]);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*change_handler_1*/ ctx[30]),
					listen(input, "input", /*input_handler_1*/ ctx[31]),
					listen(input, "beforeinput", /*beforeinput_handler_1*/ ctx[32]),
					listen(input, "change", /*input_change_handler_1*/ ctx[41])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 16384) {
				input.disabled = /*disabled*/ ctx[14];
			}

			if (dirty[0] & /*group*/ 8) {
				input.checked = ~/*group*/ ctx[3].indexOf(input.__value);
			}

			if (dirty[0] & /*checked*/ 4) {
				input.checked = /*checked*/ ctx[2];
			}

			if (dirty[0] & /*value*/ 16) {
				set_input_value(input, /*value*/ ctx[4]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_1*/ ctx[40](null);
			/*$$binding_groups*/ ctx[38][0].splice(/*$$binding_groups*/ ctx[38][0].indexOf(input), 1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (183:2) {#if variant === "radio"}
function create_if_block_5(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element_1("input");
			attr(input, "type", "radio");
			input.hidden = true;
			input.__value = /*value*/ ctx[4];
			input.value = input.__value;
			input.checked = /*checked*/ ctx[2];
			input.disabled = /*disabled*/ ctx[14];
			/*$$binding_groups*/ ctx[38][0].push(input);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			input.checked = input.__value === /*group*/ ctx[3];
			/*input_binding*/ ctx[39](input);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*change_handler*/ ctx[27]),
					listen(input, "input", /*input_handler*/ ctx[28]),
					listen(input, "beforeinput", /*beforeinput_handler*/ ctx[29]),
					listen(input, "change", /*input_change_handler*/ ctx[37])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 16) {
				input.__value = /*value*/ ctx[4];
				input.value = input.__value;
			}

			if (dirty[0] & /*checked*/ 4) {
				input.checked = /*checked*/ ctx[2];
			}

			if (dirty[0] & /*disabled*/ 16384) {
				input.disabled = /*disabled*/ ctx[14];
			}

			if (dirty[0] & /*group*/ 8) {
				input.checked = input.__value === /*group*/ ctx[3];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[38][0].splice(/*$$binding_groups*/ ctx[38][0].indexOf(input), 1);
			/*input_binding*/ ctx[39](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (120:2) {#if hint}
function create_if_block_3(ctx) {
	let textblock;
	let current;

	textblock = new TextBlock({
			props: {
				class: "menu-flyout-item-hint",
				variant: "caption",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(textblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textblock_changes = {};

			if (dirty[0] & /*hint*/ 2048 | dirty[1] & /*$$scope*/ 4096) {
				textblock_changes.$$scope = { dirty, ctx };
			}

			textblock.$set(textblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textblock, detaching);
		}
	};
}

// (121:3) <TextBlock class="menu-flyout-item-hint" variant="caption">
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text(/*hint*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*hint*/ 2048) set_data(t, /*hint*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (123:2) {#if cascading}
function create_if_block_1(ctx) {
	let svg;
	let path;
	let t;
	let if_block_anchor;
	let current;
	let if_block = /*open*/ ctx[0] && /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && create_if_block_2(ctx);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(path, "d", "M4.64645 2.14645C4.45118 2.34171 4.45118 2.65829 4.64645 2.85355L7.79289 6L4.64645 9.14645C4.45118 9.34171 4.45118 9.65829 4.64645 9.85355C4.84171 10.0488 5.15829 10.0488 5.35355 9.85355L8.85355 6.35355C9.04882 6.15829 9.04882 5.84171 8.85355 5.64645L5.35355 2.14645C5.15829 1.95118 4.84171 1.95118 4.64645 2.14645Z");
			attr(path, "fill", "currentColor");
			attr(svg, "class", "menu-flyout-item-arrow svelte-s7v067");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "12");
			attr(svg, "height", "12");
			attr(svg, "viewBox", "0 0 12 12");
			attr(svg, "fill", "none");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*open*/ ctx[0] && /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open, $$slots, disabled*/ 16793601) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (137:3) {#if open && $$slots.flyout && !disabled}
function create_if_block_2(ctx) {
	let div;
	let menuflyoutsurface;
	let updating_element;
	let arrowNavigation_action;
	let current;
	let mounted;
	let dispose;

	function menuflyoutsurface_element_binding(value) {
		/*menuflyoutsurface_element_binding*/ ctx[33](value);
	}

	let menuflyoutsurface_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*subMenuElement*/ ctx[1] !== void 0) {
		menuflyoutsurface_props.element = /*subMenuElement*/ ctx[1];
	}

	menuflyoutsurface = new MenuFlyoutSurface({ props: menuflyoutsurface_props });
	binding_callbacks.push(() => bind(menuflyoutsurface, 'element', menuflyoutsurface_element_binding));
	/*menuflyoutsurface_binding*/ ctx[34](menuflyoutsurface);

	return {
		c() {
			div = element_1("div");
			create_component(menuflyoutsurface.$$.fragment);
			attr(div, "id", /*menuId*/ ctx[19]);
			attr(div, "class", "menu-flyout-submenu-anchor svelte-s7v067");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(menuflyoutsurface, div, null);
			/*div_binding*/ ctx[35](div);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(arrowNavigation_action = arrowNavigation.call(null, div, { preventTab: true, stopPropagation: true }));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const menuflyoutsurface_changes = {};

			if (dirty[1] & /*$$scope*/ 4096) {
				menuflyoutsurface_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*subMenuElement*/ 2) {
				updating_element = true;
				menuflyoutsurface_changes.element = /*subMenuElement*/ ctx[1];
				add_flush_callback(() => updating_element = false);
			}

			menuflyoutsurface.$set(menuflyoutsurface_changes);
		},
		i(local) {
			if (current) return;
			transition_in(menuflyoutsurface.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menuflyoutsurface.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*menuflyoutsurface_binding*/ ctx[34](null);
			destroy_component(menuflyoutsurface);
			/*div_binding*/ ctx[35](null);
			mounted = false;
			dispose();
		}
	};
}

// (144:5) <MenuFlyoutSurface bind:element={subMenuElement} bind:this={menu}>
function create_default_slot(ctx) {
	let current;
	const flyout_slot_template = /*#slots*/ ctx[26].flyout;
	const flyout_slot = create_slot(flyout_slot_template, ctx, /*$$scope*/ ctx[43], get_flyout_slot_context);

	return {
		c() {
			if (flyout_slot) flyout_slot.c();
		},
		m(target, anchor) {
			if (flyout_slot) {
				flyout_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (flyout_slot) {
				if (flyout_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						flyout_slot,
						flyout_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(flyout_slot_template, /*$$scope*/ ctx[43], dirty, get_flyout_slot_changes),
						get_flyout_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(flyout_slot, local);
			current = true;
		},
		o(local) {
			transition_out(flyout_slot, local);
			current = false;
		},
		d(detaching) {
			if (flyout_slot) flyout_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_if_block_4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variant*/ ctx[9] === "standard" || /*__depth*/ ctx[15]) return 0;
		if (/*variant*/ ctx[9] === "radio" || /*variant*/ ctx[9] === "toggle") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"variant","cascading","hint","selected","checked","indented","group","value","disabled","open","__depth","class","element","inputElement","inputLabelElement","subMenuAnchorElement","subMenuElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { variant = "standard" } = $$props;
	let { cascading = false } = $$props;
	let { hint = undefined } = $$props;
	let { selected = false } = $$props;
	let { checked = false } = $$props;
	let { indented = false } = $$props;
	let { group = [] } = $$props;
	let { value = undefined } = $$props;
	let { disabled = false } = $$props;
	let { open = false } = $$props;
	let { __depth = false } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;
	let { inputElement = null } = $$props;
	let { inputLabelElement = null } = $$props;
	let { subMenuAnchorElement = null } = $$props;
	let { subMenuElement = null } = $$props;
	const forwardEvents = createEventForwarder(get_current_component());
	const dispatch = createEventDispatcher();
	const closeFlyout = getContext("closeFlyout");
	const menuId = uid("fds-menu-flyout-submenu-");
	let menu = null;
	let subMenuQueue = { open: false, close: false };

	function close(event) {
		setTimeout(() => {
			if (!cascading && closeFlyout) closeFlyout(event);
		});
	}

	function handleKeyDown(event) {
		const { key, target } = event;

		if (key === "Enter" || key === " ") {
			event.preventDefault();
			target.click();
		}

		if (cascading) {
			if (key === "ArrowRight") {
				event.stopPropagation();
				$$invalidate(0, open = true);
			} else if (open && key === "ArrowLeft") {
				event.stopPropagation();
				$$invalidate(0, open = false);
				element.focus();
			}
		}
	}

	function handleMouseEnter() {
		subMenuQueue.close = false;
		subMenuQueue.open = true;

		setTimeout(
			() => {
				if (subMenuQueue.open) $$invalidate(0, open = true);
			},
			500
		);
	}

	function handleMouseLeave() {
		subMenuQueue.close = true;
		subMenuQueue.open = false;

		setTimeout(
			() => {
				if (subMenuQueue.close) $$invalidate(0, open = false);
			},
			500
		);
	}

	const $$binding_groups = [[]];

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function menuflyoutsurface_element_binding(value) {
		subMenuElement = value;
		$$invalidate(1, subMenuElement);
	}

	function menuflyoutsurface_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			menu = $$value;
			$$invalidate(17, menu);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			subMenuAnchorElement = $$value;
			$$invalidate(8, subMenuAnchorElement);
		});
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(5, element);
		});
	}

	function input_change_handler() {
		group = this.__value;
		$$invalidate(3, group);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(6, inputElement);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(6, inputElement);
		});
	}

	function input_change_handler_1() {
		group = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
		checked = this.checked;
		value = this.value;
		$$invalidate(3, group);
		$$invalidate(2, checked);
		$$invalidate(4, value);
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputLabelElement = $$value;
			$$invalidate(7, inputLabelElement);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('variant' in $$new_props) $$invalidate(9, variant = $$new_props.variant);
		if ('cascading' in $$new_props) $$invalidate(10, cascading = $$new_props.cascading);
		if ('hint' in $$new_props) $$invalidate(11, hint = $$new_props.hint);
		if ('selected' in $$new_props) $$invalidate(12, selected = $$new_props.selected);
		if ('checked' in $$new_props) $$invalidate(2, checked = $$new_props.checked);
		if ('indented' in $$new_props) $$invalidate(13, indented = $$new_props.indented);
		if ('group' in $$new_props) $$invalidate(3, group = $$new_props.group);
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(14, disabled = $$new_props.disabled);
		if ('open' in $$new_props) $$invalidate(0, open = $$new_props.open);
		if ('__depth' in $$new_props) $$invalidate(15, __depth = $$new_props.__depth);
		if ('class' in $$new_props) $$invalidate(16, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(5, element = $$new_props.element);
		if ('inputElement' in $$new_props) $$invalidate(6, inputElement = $$new_props.inputElement);
		if ('inputLabelElement' in $$new_props) $$invalidate(7, inputLabelElement = $$new_props.inputLabelElement);
		if ('subMenuAnchorElement' in $$new_props) $$invalidate(8, subMenuAnchorElement = $$new_props.subMenuAnchorElement);
		if ('subMenuElement' in $$new_props) $$invalidate(1, subMenuElement = $$new_props.subMenuElement);
		if ('$$scope' in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*open*/ 1) {
			$: dispatch(open ? "open" : "close");
		}

		if ($$self.$$.dirty[0] & /*open, menu, subMenuElement*/ 131075) {
			$: if (open && menu && tabbable(subMenuElement).length > 0) tabbable(subMenuElement)[0].focus();
		}
	};

	return [
		open,
		subMenuElement,
		checked,
		group,
		value,
		element,
		inputElement,
		inputLabelElement,
		subMenuAnchorElement,
		variant,
		cascading,
		hint,
		selected,
		indented,
		disabled,
		__depth,
		className,
		menu,
		forwardEvents,
		menuId,
		close,
		handleKeyDown,
		handleMouseEnter,
		handleMouseLeave,
		$$slots,
		$$restProps,
		slots,
		change_handler,
		input_handler,
		beforeinput_handler,
		change_handler_1,
		input_handler_1,
		beforeinput_handler_1,
		menuflyoutsurface_element_binding,
		menuflyoutsurface_binding,
		div_binding,
		li_binding,
		input_change_handler,
		$$binding_groups,
		input_binding,
		input_binding_1,
		input_change_handler_1,
		label_binding,
		$$scope
	];
}

class MenuFlyoutItem extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				variant: 9,
				cascading: 10,
				hint: 11,
				selected: 12,
				checked: 2,
				indented: 13,
				group: 3,
				value: 4,
				disabled: 14,
				open: 0,
				__depth: 15,
				class: 16,
				element: 5,
				inputElement: 6,
				inputLabelElement: 7,
				subMenuAnchorElement: 8,
				subMenuElement: 1
			},
			add_css,
			[-1, -1]
		);
	}
}

export default MenuFlyoutItem;